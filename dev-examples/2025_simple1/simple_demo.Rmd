---
title: 'Demo of new simple1 version'
output: pdf_document
author: Sasha D. Hafner
date: "`r format(Sys.time(), '%d %B, %Y %H:%M')`"
---

# Overview
This demo shows:

1. basic usage,
2. variable substrates,
3. time-variable inputs,
4. speciation (proton-transfer reactions),
5. inhibition,
6. COD balance,

# Prep

```{r}
devtools::load_all()
```

# Function arguments
The argument list currently looks like this:

```
abm <- function(
  days = 365,                 # Number of days to run
  delta_t = 1,                # Time step for output
  times = NULL,               # Optional vector of times for output
  mng_pars,
  man_pars,
  init_pars = list(conc_init =  c(man_pars$comp_fresh, man_pars$VFA_fresh)),
  grp_pars,
  mic_pars,
  sub_pars,
  chem_pars,
  inhib_pars = NULL,
  mt_pars = NULL,
  ctrl_pars = list(respir = TRUE,
                   pH_inhib = FALSE, 
                   approx_method = 'early',
                   par_key = '\\.',
                   rates_calc = 'instant'),
  var_pars = list(var = NULL),
  add_pars = NULL,
  pars = NULL,
  startup = 0,                # Number of times complete simulation should be run before returning results
  starting = NULL,            # Output from previous simulation to be starting condition for new one
  value = 'ts',               # Type of output
  warn = TRUE) {
```

The main changes in arguments are:

* new `sub_pars` for defining substrates
* new `ctrl_pars` for some "control" parameters
* new `var_pars` for *any* parameters that change over time

I have removed the default `*_pars` objects for now.

# 1. Basic behavior
The simplest usage is with constant slurry production rate and a fixed schedule.
We need to set some parameters, first management parameters.

```{r}
mng_pars = list(slurry_prod_rate = 10000, 
                slurry_mass = 1000,     
                storage_depth = 2,     
                resid_depth = 0.1,      
                area = 100,              
                empty_int = 100,          
                temp_C = 20,
                wash_water = 0,            
                wash_int = NA,
                rest_d = 0,
                resid_enrich = 1)
```

Next substrate parameters, a new argument.
This defines substrates.
We could have any number with any names.
Note that hydrolysis uses CTM again (like anything here, that could be changed).

```{r}
sub_pars <- list(subs = c('VSd'),
                 T_opt_hyd = c(VSd = 60),
                 T_min_hyd = c(VSd = 0),
                 T_max_hyd = c(VSd = 90),
                 hydrol_opt = c(VSd = 0.1),
                 sub_fresh = c(VSd = 50),
                 sub_init = c(VSd = 50))
```

Microbial parameters are similar to other ABM versions, but inhibition is set separately now.

```{r}
grp_pars <- list(grps = c('m0', 'm1', 'm2','sr1'),
                 yield = c(default = 0.05, sr1 = 0.065),
                 xa_fresh = c(all = 0.05),
                 xa_init = c(all = 0.05),
                 dd_rate = c(all = 0.02),
                 ks = c(default = 1, sr1 = 0.5),
                 qhat_opt = c(m0 = 1, m1 = 1, m2 = 2, sr1 = 9),
                 T_opt = c(m0 = 18, m1 = 18, m2 = 28, sr1 = 44),
                 T_min = c(m0 = 0, m1 = 6.41, m2 = 6.41, sr1 = 0),
                 T_max = c(m0 = 25, m1 = 25, m2 = 38, sr1 = 51))
```

The `dd_rate_xa` parameter is for "death and decay".


```{r}
mic_pars <- list(dd_rate_xa = 0.02)
```

These last two arguments are similar to other versions.
VFA is hard-wired and so has its own elements.

```{r}
man_pars <- list(VFA_fresh = c(VFA = 2), pH = 7, dens = 1000)

chem_pars <- list(COD_conv = c(CH4 = 1/0.2507, xa = 1/0.7069561,
                               VFA = 1/0.9383125, S = 1/0.5015, VS = 1/0.69, 
                               CO2_aer = 1/0.436, CO2_sr = 1/1.2, 
                               C_xa = 1/0.3753125))
```

```{r}
out1 <- abm(365,
            mng_pars = mng_pars,
            man_pars = man_pars,
            grp_pars = grp_pars,
            mic_pars = mic_pars,
            sub_pars = sub_pars,
            chem_pars = chem_pars)
```

Output is similar to other versions.
(The `value` argument does not currently work.)

```{r}
head(out1)
tail(out1)
```

The effluent columns are cumulative.
Is this what we had before?
I did it for COD balance checking.
We will have to discuss what is needed.

Here are some results.

```{r}
plot(slurry_mass ~ time, data = out1, type = 'l')
plot(CH4_emis_rate ~ time, data = out1, type = 'l')
plot(VSd_conc ~ time, data = out1, type = 'l')
plot(VFA_conc ~ time, data = out1, type = 'l')
```

And methanogens.

```{r}
line_colors <- c('red', 'blue', 'purple','orange')
matplot(out1$time, out1[, nn <- c('m0','m1','m2','sr1')]/1000, 
        type = 'l', lty = c(1:length(nn)), col = line_colors, ylab = 'Microbial biomass (kg)')
legend("topright", legend = nn, lty = c(1:length(nn)), col = line_colors, lwd = 1, cex = 0.8)
```

# 2. Substrate flexibility

Particulate substrates are defined in `sub_pars` now and there are no specific substrates hard-wired in the code.
VFA is the only intermediate, and it is hard-wired.
Here we will use three substrates.
Parameter values have no connection to reality.

```{r}
sub_pars2 <- list(subs = c('cellulose', 'protein', 'lipids'),
                  T_opt_hyd = c(all = 60),
                  T_min_hyd = c(all = 0),
                  T_max_hyd = c(all = 90),
                  hydrol_opt = c(lipids = 0.1, protein = 0.01, cellulose = 0.05),
                  sub_fresh = c(lipids = 3, protein = 20, cellulose = 35),
                  sub_init = c(lipids = 3, protein = 20, cellulose = 35))
```

```{r}
out2 <- abm(365,
            mng_pars = mng_pars,
            man_pars = man_pars,
            grp_pars = grp_pars,
            mic_pars = mic_pars,
            sub_pars = sub_pars2,
            chem_pars = chem_pars)
```


```{r}
plot(slurry_mass ~ time, data = out2, type = 'l')
lines(slurry_mass ~ time, data = out1, col = 'red')

plot(CH4_emis_rate ~ time, data = out1, type = 'l')
lines(CH4_emis_rate ~ time, data = out2, col = 'red')

plot(lipids_conc ~ time, data = out2, type = 'l')
plot(protein_conc ~ time, data = out2, type = 'l')
plot(cellulose_conc ~ time, data = out2, type = 'l')

plot(VFA_conc ~ time, data = out1, type = 'l')
lines(VFA_conc ~ time, data = out2, col = 'red')
```

This flexibility comes from an approach similar to what we used for microbial groups.

# 3. Time-variable inputs part 1
The `abm()` function can handle variability over time in any inputs now.
Here slurry mass and temperature will vary.

```{r}
var_dat <- data.frame(time = c(0, 1, 10, 15, 30), 
                      slurry_mass = c(1000, 7000, 2000, 1500, 3000),
                      temp_C = c(10, 15, 15, 20, 20))

plot(slurry_mass ~ time, data = var_dat, type = 'o')
plot(temp_C ~ time, data = var_dat, type = 'o')
```

This data frame goes in the `var_pars` argument, which must be a list, even though it might have a single element named `var`.
The `var` element is the only required one.
The `var` data frame must have a `slurry_mass` column if it is used--it is not possible to use an `abm_regular()`-like approach with variable temperature etc.

```{r}
var_pars <- list(var = var_dat)
```

```{r}
out3a <- abm(50,
             mng_pars = mng_pars,
             man_pars = man_pars,
             grp_pars = grp_pars,
             mic_pars = mic_pars,
             sub_pars = sub_pars,
             chem_pars = chem_pars,
             var_pars = var_pars)
```


```{r}
plot(slurry_mass ~ time, data = out3a, type = 'l')
```

The "late" and "mid" options are still available, but now through `ctrl_pars`.
Here we can change the value through `add_pars`

```{r}
out3b <- abm(50,
             mng_pars = mng_pars,
             man_pars = man_pars,
             grp_pars = grp_pars,
             mic_pars = mic_pars,
             sub_pars = sub_pars,
             chem_pars = chem_pars,
             var_pars = var_pars,
             add_pars = list(approx_method = 'late'))
```

```{r}
out3c <- abm(50,
             mng_pars = mng_pars,
             man_pars = man_pars,
             grp_pars = grp_pars,
             mic_pars = mic_pars,
             sub_pars = sub_pars,
             chem_pars = chem_pars,
             var_pars = var_pars,
             add_pars = list(approx_method = 'mid'))
```

```{r}
plot(slurry_mass ~ time, data = out3a, type = 'l')
lines(slurry_mass ~ time, data = out3b, col = 'red')
lines(slurry_mass ~ time, data = out3c, col = 'blue')
```

```{r}
plot(CH4_emis_cum ~ time, data = out3a, type = 'l')
lines(CH4_emis_cum ~ time, data = out3b, col = 'red')
lines(CH4_emis_cum ~ time, data = out3c, col = 'blue')
```

# 4. Time-variable inputs part 2
Here we'll vary fresh substrate concentrations over time.

First the data frame with slurry mass.

```{r}
var_dat <- data.frame(time = c(0, 1, 10, 15, 30, 50), 
                      slurry_mass = c(1000, 7000, 2000, 5000, 3000, 10000))
var_dat
```

Then add `sub_fresh` values.
Each row needs a list containing a named vector.
This is somewhat unusual data frame usage, and there is a user-friendly alternative based on additional data frames in the `var` argument (see next section).
But I've kept this demo.

```{r}
var_dat
var_dat$sub_fresh <- rep(list(c(VSd = 50)), nrow(var_dat))
var_dat$sub_fresh[3] <- list(c(VSd = 100))
var_dat$sub_fresh[4] <- list(c(VSd = 10))
var_dat$sub_fresh[5] <- list(c(VSd = 0))
var_dat$sub_fresh[6] <- list(c(VSd = 200))
var_dat
var_dat[1, 3]
var_dat[5, 3]
```

```{r}
devtools::load_all()
out4a <- abm(100,
             mng_pars = mng_pars,
             man_pars = man_pars,
             grp_pars = grp_pars,
             mic_pars = mic_pars,
             sub_pars = sub_pars,
             chem_pars = chem_pars,
             var_pars = var_pars)
```


```{r}
plot(slurry_mass ~ time, data = out4a, type = 'l')
plot(CH4_emis_rate ~ time, data = out4a, type = 'l')
plot(var_dat$time, as.vector(lapply(var_dat$sub_fresh, `[[`, 1)), type = 'p', col = 'red')
lines(VSd_conc ~ time, data = out4a, type = 'p')
plot(VFA_conc ~ time, data = out4a, type = 'l')
```

Let's vary some microbial parameters as well.
And pH.

```{r}
var_dat <- data.frame(time = c(0, 1, 10, 15, 30, 50), 
                      slurry_mass = c(1000, 7000, 2000, 5000, 3000, 10000),
                      pH = 7 - 0:5/10)
var_dat
```


VSd.

```{r}
var_dat$sub_fresh <- rep(list(c(VSd = 50)), nrow(var_dat))
var_dat$sub_fresh[3] <- list(c(VSd = 100))
```

Some microbial parameters for a shift in temperature optima, "adaptation" for example.

```{r}
for (i in 1:nrow(var_dat)) {
  var_dat$T_opt[i] <- list(grp_pars$T_opt + 2 * i)
}
var_dat
```

```{r}
out4b <- abm(100,
             mng_pars = mng_pars,
             man_pars = man_pars,
             grp_pars = grp_pars,
             mic_pars = mic_pars,
             sub_pars = sub_pars,
             chem_pars = chem_pars,
             var_pars = var_pars)
```

```{r}
plot(slurry_mass ~ time, data = out4b, type = 'l')
plot(CH4_emis_rate ~ time, data = out4b, type = 'l')
plot(VSd_conc ~ time, data = out4b, type = 'l')
plot(VFA_conc ~ time, data = out4b, type = 'l')
```

# 5. Time-variable inputs part 3
The list-in-data frame approach is clunky.
Here is an alternative.

```{r}
var_dat <- data.frame(time = c(0, 1, 10, 15, 30, 50), 
                      slurry_mass = c(1000, 7000, 2000, 5000, 3000, 10000))
var_dat
```

Make a separate data frame for each other argument (any name, but note column names!).

```{r}
sub_fresh_dat = data.frame(time = c(0, 1, 10, 15, 30, 50), 
                       VSd = c(50, 100, 0, 0, 200, 50))
```

```{r}
T_opt_dat = data.frame(time = c(0, 1, 10, 15, 30, 50), 
                       m1 = 20 + 0:5 * 2,
                       m2 = 20 + 0:5 * 2,
                       m3 = 30 + 0:5 * 2,
                       sr1 = 46 + 0:5 * 2)
```

and combine them in a list, using the parameter element names for element names (e.g., `sub_fresh` is the name of an element in `sub_pars`).

```{r}
var_pars <- list(var = var_dat, sub_fresh = sub_fresh_dat, T_opt = T_opt_dat)
```

```{r}
devtools::load_all()
out5 <- abm(100,
             mng_pars = mng_pars,
             man_pars = man_pars,
             grp_pars = grp_pars,
             mic_pars = mic_pars,
             sub_pars = sub_pars,
             chem_pars = chem_pars,
             var_pars = var_pars)
```

```{r}
plot(slurry_mass ~ time, data = out5, type = 'l')
plot(CH4_emis_rate ~ time, data = out5, type = 'l')
plot(VSd_conc ~ time, data = out5, type = 'l')
plot(VFA_conc ~ time, data = out5, type = 'l')
```

# 6. Flexible solutes
Any conservative solute can be added in `man_pars`, using any names.
I am moving toward using a "master species" approach, so it makes sense to use the chemical formula of the primary species, with `p` or `m` for a charge symbol.
The `comp` part of the name below is for "component".

```{r}
man_pars6 <- list(comps = c('H2S', 'SO4m2', 'NH4p'),
                 comp_fresh = c(H2S = 0.01, SO4m2 = 0.2, NH4p = 2.5), 
                 VFA_fresh = c(VFA = 2),
                 pH = 7, dens = 1000)
```

Note that `VFA` is still special--it has a fixed name in the code and is not conservative.


```{r}
devtools::load_all()
out6a <- abm(365,
            mng_pars = mng_pars,
            man_pars = man_pars6,
            grp_pars = grp_pars,
            mic_pars = mic_pars,
            sub_pars = sub_pars,
            chem_pars = chem_pars)
```

```{r}
tail(out6a)
head(out6a)
```

Conservative components are boring in output (without inhibition or volatilization).

```{r}
plot(NH4p_conc ~ time, data = out6a)
plot(NH4p ~ time, data = out6a)
```

We can see dilution effects at least if some washing water is added.

```{r}
mng_pars6 = list(slurry_prod_rate = 10000, 
                slurry_mass = 1000,     
                storage_depth = 2,     
                resid_depth = 0.1,      
                area = 100,              
                empty_int = 100,          
                temp_C = 20,
                wash_water = 100000,            
                wash_int = 100,
                rest_d = 0,
                resid_enrich = 1)

```

```{r}
out6b <- abm(365,
            mng_pars = mng_pars6,
            man_pars = man_pars6,
            grp_pars = grp_pars,
            mic_pars = mic_pars,
            sub_pars = sub_pars,
            chem_pars = chem_pars)
```

```{r}
plot(NH4p_conc ~ time, data = out6b, type = 'l')
lines(NH4p_conc ~ time, data = out6a, col = 'red')
```

# 7. Speciation
Acid-base reactions are needed for inhibition.
They can be added for any component.
The `chem_pars` argument can accept temperature-dependent log ka expressions.

```{r}
man_pars7 <- list(comps = c('H2S', 'NH4p'),
                 comp_fresh = c(H2S = 0.01, NH4p = 2.5), 
                 VFA_fresh = c(VFA = 2),
                 pH = 7, dens = 1000)

chem_pars7 <- list(COD_conv = c(CH4 = 1/0.2507, xa = 1/0.7069561,
                               VFA = 1/0.9383125, S = 1/0.5015, VS = 1/0.69, 
                               CO2_aer = 1/0.436, CO2_sr = 1/1.2, 
                               C_xa = 1/0.3753125),
                   specs = c('NH3', 'HSm', 'VFAm'),
                   mspec = c(NH3 = 'NH4p', HSm = 'H2S', VFAm = 'VFA'),
                   lka = c(NH3 = '- 0.09046 - 2729.31/temp_K', 
                           HSm = '- 3448.7/temp_K + 47.479 - 7.5227 * log(temp_K)',
                           VFAm = '-4.8288 + 21.42/temp_K')
)
```

```{r}
out7 <- abm(365,
            mng_pars = mng_pars,
            man_pars = man_pars6,
            grp_pars = grp_pars,
            mic_pars = mic_pars,
            sub_pars = sub_pars,
            chem_pars = chem_pars7)
```

```{r}
head(out7)
```

But chemical species are actually ignored unless they are used in inhibition.

# 8. Inhibition

Any chemical species can inhibit any microbial group.
Inhibition parameters (currently initial and complete concentrations, with linear response, why not?) are entered in a matrix.

```{r}
ilwr <- matrix(
  c(5, 0.2, 10, 0.5,
    5, 0.2, 10, 0.5,
    5, 0.2, 10, 0.5,
    5, 0.2, 10, 0.5),
  nrow = 4,
  byrow = TRUE,
  dimnames = list(
    c('m0', 'm1', 'm2', 'sr1'),
    c('NH4p', 'NH3', 'VFAm', 'VFA')
  )
)

iupr <- matrix(
  c(9, 0.9, 30, 1,
    9, 0.9, 30, 1,
    9, 0.9, 30, 1,
    9, 0.9, 30, 1),
  nrow = 4,
  byrow = TRUE,
  dimnames = list(
    c('m0', 'm1', 'm2', 'sr1'),
    c('NH4p', 'NH3', 'VFAm', 'VFA')
  )
)

inhib_pars <- list(
  ilwr = ilwr,
  iupr = iupr
)

inhib_pars
                  
```

```{r}
man_pars8 <- list(comps = c('H2S', 'NH4p'),
                 comp_fresh = c(H2S = 0.01, 
				                        NH4p = 2.5), 
                 VFA_fresh = c(VFA = 2),
                 pH = 7, dens = 1000)

chem_pars8 <- list(COD_conv = c(CH4 = 1/0.2507, xa = 1/0.7069561,
                               VFA = 1/0.9383125, S = 1/0.5015, VS = 1/0.69, 
                               CO2_aer = 1/0.436, CO2_sr = 1/1.2, 
                               C_xa = 1/0.3753125),
                   specs = c('NH3', 'HSm', 'VFAm'),
                   mspec = c(NH3 = 'NH4p', HSm = 'H2S', VFAm = 'VFA'),
                   lka = c(NH3 = '- 0.09046 - 2729.31/temp_K', 
                           HSm = '- 3448.7/temp_K + 47.479 - 7.5227* log(temp_K)',
                           VFAm = '-4.8288 + 21.42/temp_K')
)
```


```{r}
out8 <- abm(365,
            mng_pars = mng_pars,
            man_pars = man_pars7,
            grp_pars = grp_pars,
            mic_pars = mic_pars,
            sub_pars = sub_pars,
            chem_pars = chem_pars7,
            inhib_pars = inhib_pars
)
```

```{r}
plot(CH4_emis_rate ~ time, data = out7, type = 'l')
lines(CH4_emis_rate ~ time, data = out8, col = 'red')

plot(CH4_emis_cum ~ time, data = out7, type = 'l')
lines(CH4_emis_cum ~ time, data = out8, col = 'red')
```

# 9. COD balance
There is now a `checkCOD()` function that runs on `abm()` results before returning them.
For now the tolerance is fixed at 1%.
Some of the examples above do not meet that criterion for some reason.
At least one shows a real problem that needs to be identified.

 
